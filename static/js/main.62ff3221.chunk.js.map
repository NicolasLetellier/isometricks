{"version":3,"sources":["logo.svg","editor/gridUtils.js","editor/toolbar/Toolbar.js","editor/frame/TrianglesGrid.js","editor/frame/Frame.js","editor/Editor.js","editor/eventsUtils.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","TRIANGLE_EDGE_LENGTH","giveTriangleHeight","triangleEdgeLength","Math","sqrt","giveTriangleCoordinates","x","y","orientation","x1","x2","y1","y2","y3","topVertexCoord","sideVertexCoord","bottomVertexCoord","triangleBuilder","giveTriangleOrientation","coordinates","Toolbar","setActiveFace","backwardInHistory","forwardInHistory","className","type","onClick","TrianglesGrid","presentation","gridDimensionsInTriangles","trianglesMap","triangleClickHandler","trianglesPolygons","triangleMapData","triangleGridCoord","topCoord","sideCoord","bottomCoord","push","key","points","data-orientation","stroke","strokeWidth","fill","height","width","Frame","gridWidthInTriangles","gridHeightInTriangles","polygonStack","gridDimensions","drawingPolygons","forEach","polygon","index","reduce","acc","value","viewBox","preserveAspectRatio","FIXED_GRID_DIMENSIONS","Editor","useState","activeFace","stacksHistory","setStacksHistory","historyNavIndex","setHistoryNavIndex","historyLastIndex","length","currentHistoryIndex","map","trianglesMapBuilder","addPolygonIntoStacksHistory","actualisedPolygonStack","previousStack","previousStackCopy","polygonCoordsString","flat","toString","i","splice","concat","actualiseStack","slicedHistory","slice","triangleMapCoord","eventTriangleCoord","upperTriangle","undefined","upperTriangleCoord","lowerTriangle","lowerTriangleCoord","onRightRow","onRightTriangleCoord","onLeftRow","onLeftTriangleCoord","calculateFacePoints","App","src","logo","alt","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.62ff3221.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.25bf045c.svg\";","\n// WARNING: It is assumed that we will only use the hexagon\n// orientation that is really usefull for isometric drawings:\n// hexagons 'pointy topped'\n// a LOT of calculations are extrapolated based on this assumption\n\n// Here we define this value (1) as a universal basis of the project.\n// This will help to visualize other values like svg grid dimensions\nconst TRIANGLE_EDGE_LENGTH = 1;\n\nfunction giveTriangleHeight(triangleEdgeLength) {\n  return Math.sqrt(3) / 2 * triangleEdgeLength;\n}\n\n// Give orientation of triangle, pointing to left or right\nfunction giveTriangleOrientation(x, y) {\n  // This rule works because we decided to start grid\n  // at 0,0 with a left triangle.\n  // Using % as we won't have negative coordinates.\n  return (x % 2 === y % 2) ? 'left' : 'right';\n}\n\n// Coordinate system:\n// starts at 0, 0 (top left)\n// x (horizontal) increase to the right\n// y (vertical) increase to the bottom\n\n// Coordinates are given ordered, for any given triangle,\n// by increasing y:\n// first, top vertex coordinates\n// second, coordinates of the sided vertex (pointing to left or right)\n// third, bottom vertex coordinates\nfunction giveTriangleCoordinates(x, y, orientation) {\n  // for each triangle, we need to calculate:\n  // two values of x: x1 and x2\n  // and three values of y: y1, y2 and y3\n\n  const x1 = giveTriangleHeight(x * TRIANGLE_EDGE_LENGTH);\n  const x2 = giveTriangleHeight((x + 1) * TRIANGLE_EDGE_LENGTH);\n  const y1 = y * (TRIANGLE_EDGE_LENGTH / 2);\n  const y2 = (y * (TRIANGLE_EDGE_LENGTH / 2)) + (TRIANGLE_EDGE_LENGTH / 2);\n  const y3 = (y * (TRIANGLE_EDGE_LENGTH / 2)) + TRIANGLE_EDGE_LENGTH;\n\n  if (orientation === 'left') {\n    return {\n      topVertexCoord: [x2, y1],\n      sideVertexCoord: [x1, y2],\n      bottomVertexCoord: [x2, y3]\n    };\n  }\n  if (orientation === 'right') {\n    return {\n      topVertexCoord: [x1, y1],\n      sideVertexCoord: [x2, y2],\n      bottomVertexCoord: [x1, y3]\n    };\n  }\n}\n\nfunction triangleBuilder(x, y) {\n  const orientation = giveTriangleOrientation(x, y);\n  let triangle = {\n    orientation,\n    coordinates: giveTriangleCoordinates(x, y, orientation)\n  };\n  return triangle;\n}\n\nfunction trianglesMapBuilder(gridWidthInTriangles, gridHeightInTriangles) {\n  const map = [];\n\n  for (let x = 0; x < gridWidthInTriangles; x++) {\n    map[x] = [];\n    for (let y = 0; y < gridHeightInTriangles; y++) {\n      map[x][y] = triangleBuilder(x, y);\n    }\n  }\n  return map;\n}\n\nfunction calculateGridDimensions(gridWidthInTriangles, gridHeightInTriangles) {\n  const width = gridWidthInTriangles * giveTriangleHeight(TRIANGLE_EDGE_LENGTH);\n  const height = ((gridHeightInTriangles - 1) * TRIANGLE_EDGE_LENGTH / 2) + TRIANGLE_EDGE_LENGTH;\n  return {\n    width,\n    height\n  };\n}\n\nexport { trianglesMapBuilder, calculateGridDimensions };\n","\nimport React from 'react';\nimport './Toolbar.css';\n\nfunction Toolbar({ setActiveFace, backwardInHistory, forwardInHistory }) {\n  return (\n    <div className=\"Toolbar\">\n      <button type=\"button\" className=\"Toolbar-top\" onClick={() => setActiveFace('top')}>top</button>\n      <button type=\"button\" className=\"Toolbar-left\" onClick={() => setActiveFace('left')}>left</button>\n      <button type=\"button\" className=\"Toolbar-right\" onClick={() => setActiveFace('right')}>right</button>\n      {backwardInHistory !== null && (\n        <button type=\"button\" className=\"Toolbar-backward\" onClick={backwardInHistory}>backward</button>\n      )}\n      {forwardInHistory !== null && (\n        <button type=\"button\" className=\"Toolbar-forward\" onClick={forwardInHistory}>forward</button>\n      )}\n    </div>\n  );\n}\n\nexport default Toolbar;\n","\nimport React from 'react';\nimport './TrianglesGrid.css';\n\nfunction TrianglesGrid({\n  presentation,\n  gridDimensionsInTriangles,\n  trianglesMap,\n  triangleClickHandler\n}) {\n\n  const trianglesPolygons = [];\n  for (let x = 0; x < gridDimensionsInTriangles.width; x++) {\n    for (let y = 0; y < gridDimensionsInTriangles.height; y++) {\n      const triangleMapData = trianglesMap[x][y];\n\n      const orientation = triangleMapData.orientation;\n      const triangleGridCoord = triangleMapData.coordinates;\n      const topCoord = triangleGridCoord.topVertexCoord;\n      const sideCoord = triangleGridCoord.sideVertexCoord;\n      const bottomCoord = triangleGridCoord.bottomVertexCoord;\n\n      trianglesPolygons.push((\n        <polygon\n          key={`${x},${y}`}\n          points={`${topCoord[0]},${topCoord[1]} ${sideCoord[0]},${sideCoord[1]} ${bottomCoord[0]},${bottomCoord[1]}`}\n          data-orientation={orientation}\n          stroke={presentation.stroke}\n          strokeWidth={presentation.strokeWidth}\n          fill={presentation.fill}\n          onClick={triangleClickHandler && (\n            () => triangleClickHandler(\n              {x, y},\n              triangleMapData\n            )\n          )}\n        />\n      ));\n    }\n  }\n\n  // check g element syntax\n  return (\n    <g className=\"TrianglesGrid\">\n      {trianglesPolygons}\n    </g>\n  );\n}\n\nexport default TrianglesGrid;\n","\nimport React from 'react';\nimport TrianglesGrid from './TrianglesGrid';\nimport { calculateGridDimensions } from './../gridUtils';\nimport './Frame.css';\n\n\nfunction Frame({\n  gridDimensionsInTriangles,\n  trianglesMap,\n  triangleClickHandler,\n  polygonStack\n}) {\n  const gridDimensions = calculateGridDimensions(gridDimensionsInTriangles.width, gridDimensionsInTriangles.height);\n\n  // WARNING! we must find a way to not re-render Grid when activeFace,\n  // colors or drawing history change...\n\n  // GOAL is to change the visible grid from triangles grid to points grid,\n  // but conserve these two layers for related events\n\n  const triangleBackgroundPresentation = {\n    stroke: 'silver',\n    strokeWidth: '0.01',\n    fill: 'transparent'\n  };\n\n  const triangleEventsPresentation = {\n    stroke: 'none',\n    fill: 'transparent'\n  };\n\n  const drawingPolygons = [];\n\n  polygonStack.forEach((polygon, index) => {\n    const points = polygon.points.reduce((acc, value) => {\n      return (acc + `${value[0]},${value[1]} `);\n    }, '');\n    drawingPolygons.push((\n      <polygon\n        key={index}\n        points={points}\n        stroke=\"none\"\n        fill={polygon.fill}\n      />\n    ));\n  });\n\n  return (\n    <div className=\"Frame\">\n      <svg\n        className=\"Frame-svg\"\n        viewBox={`0 0 ${gridDimensions.width} ${gridDimensions.height}`}\n        preserveAspectRatio=\"xMidYMin\"\n      >\n        <rect\n          x=\"0\"\n          y=\"0\"\n          width={gridDimensions.width}\n          height={gridDimensions.height}\n          className=\"Frame-background\"\n          stroke=\"none\"\n          fill={'white'}\n        />\n        <TrianglesGrid\n          presentation={triangleBackgroundPresentation}\n          gridDimensionsInTriangles={gridDimensionsInTriangles}\n          trianglesMap={trianglesMap}\n        />\n        {drawingPolygons}\n        <TrianglesGrid\n          presentation={triangleEventsPresentation}\n          gridDimensionsInTriangles={gridDimensionsInTriangles}\n          trianglesMap={trianglesMap}\n          triangleClickHandler={triangleClickHandler}\n        />\n      </svg>\n    </div>\n  );\n}\n\nexport default Frame;\n","\nimport React, { useState } from 'react';\n\nimport { trianglesMapBuilder } from './gridUtils';\nimport { calculateFacePoints } from './eventsUtils';\n\nimport Toolbar from './toolbar/Toolbar';\nimport Frame from './frame/Frame';\nimport './Editor.css';\n\n// to start before having grid size selector,\n// indicated in triangles\nconst FIXED_GRID_DIMENSIONS = {\n  width: 33,\n  height: 45\n};\n\nfunction Editor() {\n  // const [gridDimensionsInTriangles, setGridDimensionsInTriangles] = useState(FIXED_GRID_DIMENSIONS);\n  const [activeFace, setActiveFace] = useState(null);\n  // history array of polygon stacks\n  // polygon stack: array of polygon objects to be draw\n  const [stacksHistory, setStacksHistory] = useState([[]]);\n  // historyNavIndex === null : not currently in history navigation\n  const [historyNavIndex, setHistoryNavIndex] = useState(null);\n\n  // length shouldn't be less than 1\n  const historyLastIndex = stacksHistory.length - 1;\n\n  function currentHistoryIndex() {\n    return (historyNavIndex === null) ? historyLastIndex : historyNavIndex;\n  }\n\n  const trianglesMap = trianglesMapBuilder(FIXED_GRID_DIMENSIONS.width, FIXED_GRID_DIMENSIONS.height);\n\n  function backwardInHistory() {\n    if (historyNavIndex === null) {\n      setHistoryNavIndex(historyLastIndex - 1);\n    } else {\n      setHistoryNavIndex(historyNavIndex - 1);\n    }\n  }\n\n  function backwardInHistoryProp() {\n    if (historyLastIndex === 0 || historyNavIndex === 0) {\n      return null;\n    } else {\n      return backwardInHistory;\n    }\n  }\n\n  function forwardInHistory() {\n    if (historyNavIndex === historyLastIndex - 1) {\n      setHistoryNavIndex(null);\n    } else {\n      setHistoryNavIndex(historyNavIndex + 1);\n    }\n  }\n\n  function forwardInHistoryProp() {\n    if (historyNavIndex === null) {\n      return null;\n    } else {\n      return forwardInHistory;\n    }\n  }\n\n  // check if this face is exactly the same as an older one,\n  // and remove it because it would be exactly covered by the new one.\n  // (maybe disable this if in case of use of transparent colors for upper one??)\n  // BE CAREFULL, it won't work in comparing 'shape' coords!\n  // if exactly repeated polygons (same colors, etc...) it will give the impression\n  // when using history nav that nothing was done on this action... but necesary if\n  // some parts of other faces are between the two equals polygons (stack order\n  // has to be corrected)\n  function actualiseStack(previousStack, polygon) {\n    let previousStackCopy = [...previousStack];\n    const polygonCoordsString = polygon.points.flat().toString();\n    for (let i = 0; i < previousStackCopy.length; i++) {\n      const previousPolygonCoordsString = previousStackCopy[i].points.flat().toString();\n      if (previousPolygonCoordsString === polygonCoordsString) {\n        previousStackCopy.splice(i, 1);\n        break; // no possible other repeated faces as it's always checked\n      }\n    }\n    return previousStackCopy.concat(polygon);\n  }\n\n  // truncate forward history to add new stack if currently in history navigation\n  function addPolygonIntoStacksHistory(polygon) {\n    const previousPolygonStack = stacksHistory[currentHistoryIndex()];\n    const actualisedPolygonStack = actualiseStack(previousPolygonStack, polygon);\n    const slicedHistory = stacksHistory.slice(0, currentHistoryIndex() + 1);\n    slicedHistory.push(actualisedPolygonStack);\n    setStacksHistory(slicedHistory);\n    setHistoryNavIndex(null);\n  }\n\n  function triangleClickHandler(triangleMapCoord, triangleMapData) {\n    if (activeFace === null) { // activeFace set to null: inactivate any click event\n      return;\n    }\n\n    const points = calculateFacePoints(\n      triangleMapCoord,\n      triangleMapData,\n      trianglesMap,\n      activeFace\n    );\n\n    if (points === undefined) { // invalid event on grid edge\n      return;\n    }\n\n    let fill; // any css color syntax accepted\n    if (activeFace === 'top') {\n      fill = 'lightskyblue';\n    } else if (activeFace === 'right') {\n      fill = 'mediumblue';\n    } else if (activeFace === 'left') {\n      fill = 'royalblue';\n    }\n\n    const polygon = {\n      type: 'face', // other will be 'shape' when implemented\n      points,\n      fill\n      // stroke and stroke-width: configurables too!\n      // orientation: needed? > probably for changing all\n      // similar faces color at once and for detecting exactly repeated faces\n    };\n\n    addPolygonIntoStacksHistory(polygon);\n  }\n\n  return (\n    <div className=\"Editor\">\n      <Toolbar\n        setActiveFace={setActiveFace}\n        backwardInHistory={backwardInHistoryProp()}\n        forwardInHistory={forwardInHistoryProp()}\n      />\n      <Frame\n        gridDimensionsInTriangles={FIXED_GRID_DIMENSIONS}\n        trianglesMap={trianglesMap}\n        triangleClickHandler={triangleClickHandler}\n        polygonStack={stacksHistory[currentHistoryIndex()]}\n      />\n    </div>\n  );\n}\n\nexport default Editor;\n","\n// return points in an array of coordinates, not svg syntax,\n// as: [[x1,y1], [x2,y2], [x3,y3], [x4,y4]]\n// (to have the same format for future 'shape' points, that COULD need\n// it for history navigation...) > BUT performance considerations (i.e. looping on it twice)?\n// return undefined if complementary triangle for this face is out of grid.\n\n// for every activeFace, points coords are ordened in only one way,\n// to enable 'repeated faces' comparisons\n// BE CAREFULL, this rule won't apply to 'shape' polygons!!\nfunction calculateFacePoints(\n  triangleMapCoord,\n  triangleMapData,\n  trianglesMap,\n  activeFace\n) {\n  const orientation = triangleMapData.orientation;\n  const eventTriangleCoord = triangleMapData.coordinates;\n\n  const points = [];\n  if (activeFace === 'left' || activeFace === 'right') {\n    if (orientation === activeFace) {\n      const upperTriangle = trianglesMap[triangleMapCoord.x][triangleMapCoord.y - 1];\n      if (upperTriangle === undefined) { // complementary triangle for this face is out of grid\n        return;\n      }\n      const upperTriangleCoord = upperTriangle.coordinates;\n      points.push(upperTriangleCoord.topVertexCoord);\n      points.push(eventTriangleCoord.topVertexCoord);\n      points.push(eventTriangleCoord.bottomVertexCoord);\n      points.push(eventTriangleCoord.sideVertexCoord);\n    } else {\n      const lowerTriangle = trianglesMap[triangleMapCoord.x][triangleMapCoord.y + 1];\n      if (lowerTriangle === undefined) { // complementary triangle for this face is out of grid\n        return;\n      }\n      const lowerTriangleCoord = lowerTriangle.coordinates;\n      points.push(eventTriangleCoord.topVertexCoord);\n      points.push(eventTriangleCoord.sideVertexCoord);\n      points.push(lowerTriangleCoord.bottomVertexCoord);\n      points.push(eventTriangleCoord.bottomVertexCoord);\n    }\n  } else if (activeFace === 'top') {\n    if (orientation === 'left') {\n      const onRightRow = trianglesMap[triangleMapCoord.x + 1];\n      if (onRightRow === undefined) { // complementary triangle for this face is out of grid\n        return;\n      }\n      const onRightTriangleCoord = onRightRow[triangleMapCoord.y].coordinates;\n      points.push(eventTriangleCoord.topVertexCoord);\n      points.push(onRightTriangleCoord.sideVertexCoord);\n      points.push(eventTriangleCoord.bottomVertexCoord);\n      points.push(eventTriangleCoord.sideVertexCoord);\n    } else if (orientation === 'right') {\n      const onLeftRow = trianglesMap[triangleMapCoord.x - 1];\n      if (onLeftRow === undefined) { // complementary triangle for this face is out of grid\n        return;\n      }\n      const onLeftTriangleCoord = onLeftRow[triangleMapCoord.y].coordinates;\n      points.push(eventTriangleCoord.topVertexCoord);\n      points.push(eventTriangleCoord.sideVertexCoord);\n      points.push(eventTriangleCoord.bottomVertexCoord);\n      points.push(onLeftTriangleCoord.sideVertexCoord);\n    }\n  }\n  return points;\n}\n\nexport { calculateFacePoints };\n","\nimport React from 'react';\nimport Editor from './editor/Editor';\nimport logo from './logo.svg';\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <img src={logo} className=\"App-logo\" alt=\"logo\" />\n      </header>\n      <Editor />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}